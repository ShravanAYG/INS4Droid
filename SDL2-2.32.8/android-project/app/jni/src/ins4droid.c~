const int nameWrapWidth = 200;
const int lineSpacing = 8;
const int datOffset = 350;
const int drawableOff = 200;
SDL_Color Blue = { 0, 255, 200, 255 };
SDL_Color Blue2 = { 80, 0, 255, 255 };
SDL_Color Yellow = { 128, 255, 255, 255 };
SDL_Color Gray = { 80, 80, 80, 255 };
SDL_Color Gray2 = { 30, 30, 30, 255 };
SDL_Color Red = { 255, 80, 80, 255 };
SDL_Color White = { 255, 255, 255, 255 };
SDL_Rect btnStandard = { 0, 0, 250, 80 };
double accel[3] = { 0 }, gyro[3] = { 0 };

double north;
int zerod = 0;

static pthread_mutex_t fontMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t northMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t accelMutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_mutex_t zerodMutex = PTHREAD_MUTEX_INITIALIZER;

enum btnType { btnTypeNorm, btnTypeClose, btnTypeDisabled };

struct con1 {
	int fd, n, sfd;
	char *buf;
	struct sockaddr_in *cli;
	socklen_t *len;
};

struct ThreadArgs {
	SDL_Rect datDispBox;
	SDL_Sensor **sensors;
	int numSensors;
	TTF_Font *font;
	struct con1 *con;
};

static Uint32 pixfmt;

static SDL_Surface *getSensorSurface(SDL_Rect datDispBox, SDL_Sensor **sensors,
				     int numSensors, TTF_Font *font,
				     struct con1 *con)
{
	SDL_Surface *dataSur =
	    SDL_CreateRGBSurfaceWithFormat(0, datDispBox.w, 950, 32, pixfmt);
	SDL_FillRect(dataSur, NULL, SDL_MapRGB(dataSur->format, 32, 32, 32));

	int yPos = 20, mi = 0;

	for (int i = 0; i < numSensors; i++) {
		if (!sensors[i])
			continue;

		const char *name = SDL_SensorGetName(sensors[i]);
		if (!name)
			name = "Unknown Sensor";

		float data[3] = { 0 };
		SDL_SensorGetData(sensors[i], data, 3);

		char dataText[64];
		snprintf(dataText, sizeof(dataText), "%.2f, %.2f, %.2f",
			 data[0], data[1], data[2]);

		pthread_mutex_lock(&fontMutex);
		SDL_Surface *nameSurf =
		    (font ? TTF_RenderUTF8_Blended_Wrapped(font, name, Yellow,
							   nameWrapWidth) :
		     NULL);
		SDL_Surface *dataSurf =
		    (font ? TTF_RenderUTF8_Blended(font, dataText, Blue) :
		     NULL);
		pthread_mutex_unlock(&fontMutex);

		if (nameSurf && dataSurf) {
			SDL_Rect nameDst =
			    { 20, yPos, nameSurf->w, nameSurf->h };
			SDL_BlitSurface(nameSurf, NULL, dataSur, &nameDst);

			SDL_Rect dataDst =
			    { datOffset, yPos, dataSurf->w, dataSurf->h };
			SDL_BlitSurface(dataSurf, NULL, dataSur, &dataDst);

			int blockHeight =
			    (nameSurf->h >
			     dataSurf->h) ? nameSurf->h : dataSurf->h;
			yPos += blockHeight + lineSpacing;

			SDL_Rect sepLine = { 0, yPos, dataSur->w, 1 };
			SDL_FillRect(dataSur, &sepLine,
				     SDL_MapRGB(dataSur->format, 200, 200,
						200));
			yPos += 4;
		}

		if (nameSurf)
			SDL_FreeSurface(nameSurf);
		if (dataSurf)
			SDL_FreeSurface(dataSurf);
	}
	float data[3] = { 0 };
	SDL_SensorGetData(sensors[1], data, 3);

	float mx = data[0];
	float my = data[1];

	float heading = (atan2f(my, mx) * 180.0f / M_PI) + 90.0f;
	//if (heading < 0) heading += 360.0f;

	pthread_mutex_lock(&northMutex);
	north = heading;	// store compass heading in degrees
	pthread_mutex_unlock(&northMutex);

	SDL_SensorGetData(sensors[0], data, 3);
	pthread_mutex_lock(&accelMutex);
	accel[0] = data[0];
	accel[1] = data[1];
	accel[2] = data[2];
	SDL_SensorGetData(sensors[2], data, 3);
	gyro[0] = data[0];
	gyro[1] = data[1];
	gyro[2] = data[2];
	pthread_mutex_unlock(&accelMutex);

	SDL_Rect divLine = {.x = nameWrapWidth + 50,.y = 0,.w = 1,.h =
		    dataSur->h
	};
	SDL_FillRect(dataSur, &divLine,
		     SDL_MapRGB(dataSur->format, 200, 200, 200));
	return dataSur;
}

static SDL_Surface *latestSurface = NULL;
static pthread_mutex_t surfMutex = PTHREAD_MUTEX_INITIALIZER;
static bool running = true;

static void *sensorThread(void *arg)
{
	struct ThreadArgs *args = (struct ThreadArgs *)arg;
	signal(SIGPIPE, SIG_IGN);
	struct con1 *con = args->con;
	uint64_t t = 0;

	while (running) {
		con->fd =
		    accept(con->sfd, (struct sockaddr *)con->cli, con->len);
		if (con->fd < 0) {
			if (!running)
				break;
			continue;
		}

		while (running) {
			char buff[256];
			pthread_mutex_lock(&northMutex);
			pthread_mutex_lock(&accelMutex);
			double angle = north;
			snprintf(buff, sizeof(buff),
				 "%llu [ANGLE: %f], [ACC: %f, %f, %f], [GYRO: %f, %f, %f]\n",
				 t, angle, accel[0], accel[1], accel[2],
				 gyro[0], gyro[1], gyro[2]);
			pthread_mutex_unlock(&accelMutex);
			pthread_mutex_unlock(&northMutex);

			ssize_t sent = write(con->fd, buff, strlen(buff));
			if (sent <= 0) {
				close(con->fd);
				con->fd = -1;
				break;
			}

			printf("Sent %ld bytes\n", sent);

			SDL_Surface *surf = getSensorSurface(args->datDispBox,
							     args->sensors,
							     args->numSensors,
							     args->font,
							     con);
			pthread_mutex_lock(&surfMutex);
			if (latestSurface)
				SDL_FreeSurface(latestSurface);
			latestSurface = surf;
			pthread_mutex_unlock(&surfMutex);
			usleep(35000);
			t++;
		}

		if (con->fd >= 0) {
			close(con->fd);
			con->fd = -1;
		}
	}

	free(args);
	return NULL;
}

static bool copyAssetToInternal(const char *assetName, char outPath[],
				size_t outPathLen)
{
	const char *base = SDL_AndroidGetInternalStoragePath();
	if (!base) {
		SDL_Log("Internal storage path not available");
		return false;
	}
	char dirPath[1024];
	SDL_snprintf(dirPath, sizeof(dirPath), "%s/fonts", base);
	SDL_RWops *tmp = SDL_RWFromFile(dirPath, "rb");
	if (!tmp) {
		mkdir(dirPath, 0700);
	} else {
		SDL_RWclose(tmp);
	}

	SDL_snprintf(outPath, outPathLen, "%s/fonts/%s", base, assetName);

	SDL_RWops *check = SDL_RWFromFile(outPath, "rb");

	SDL_RWops *in = SDL_RWFromFile(assetName, "rb");

	SDL_RWops *out = SDL_RWFromFile(outPath, "wb");

	char buf[8192];
	size_t n;
	bool ok = true;
	while ((n = SDL_RWread(in, buf, 1, sizeof(buf))) > 0) {
		if (SDL_RWwrite(out, buf, 1, n) != n) {
			ok = false;
			break;
		}
	}

	SDL_RWclose(in);
	SDL_RWclose(out);

	return true;
}

static TTF_Font *openFontPortable(const char *name, int ptsize)
{
	char fontPath[1024];
	if (copyAssetToInternal(name, fontPath, sizeof(fontPath))) {
		TTF_Font *f = TTF_OpenFont(fontPath, ptsize);
		return f;
	}
	const char *fallback = "/system/fonts/Roboto-Regular.ttf";
	TTF_Font *f = TTF_OpenFont(fallback, ptsize);
	return f;
}

static SDL_Texture *createBtnTexture(SDL_Renderer *ren, const char *text,
				     TTF_Font *font, enum btnType b)
{
	SDL_Surface *sur =
	    SDL_CreateRGBSurfaceWithFormat(0, btnStandard.w, btnStandard.h, 32,
					   pixfmt);
	if (!sur)
		return NULL;
	SDL_Color FG = Yellow;
	SDL_Color BG = Gray;
	// background
	if (b == btnTypeNorm) {
		FG = Yellow;
		BG = Gray;
	} else if (b == btnTypeClose) {
		FG = White;
		BG = Red;
	} else if (b == btnTypeDisabled) {
		FG = Yellow;
		BG = Gray2;
	}
	SDL_FillRect(sur, NULL, SDL_MapRGB(sur->format, BG.r, BG.g, BG.b));

	if (font && text && *text) {
		pthread_mutex_lock(&fontMutex);
		SDL_Surface *nameSurf = TTF_RenderUTF8_Blended(font, text, FG);
		pthread_mutex_unlock(&fontMutex);
		if (!nameSurf) {
			SDL_Log("TTF_RenderUTF8_Blended failed: %s",
				TTF_GetError());
		} else {
			int pad = 12;
			SDL_Rect dst;
			dst.x = (btnStandard.w - nameSurf->w) / 2;
			dst.y = (btnStandard.h - nameSurf->h) / 2;

			if (nameSurf->w <= (btnStandard.w - pad)
			    && nameSurf->h <= (btnStandard.h - pad)) {
				if (dst.x < pad / 2)
					dst.x = pad / 2;
				if (dst.y < pad / 2)
					dst.y = pad / 2;
				SDL_BlitSurface(nameSurf, NULL, sur, &dst);
			} else {
				float scaleX =
				    (float)(btnStandard.w -
					    pad) / (float)nameSurf->w;
				float scaleY =
				    (float)(btnStandard.h -
					    pad) / (float)nameSurf->h;
				float s = (scaleX < scaleY) ? scaleX : scaleY;
				int w = (int)(nameSurf->w * s);
				int h = (int)(nameSurf->h * s);
				SDL_Rect sdst = { (btnStandard.w - w) / 2,
					(btnStandard.h - h) / 2, w, h
				};
				SDL_BlitScaled(nameSurf, NULL, sur, &sdst);
			}
			SDL_FreeSurface(nameSurf);
		}
	}

	SDL_Texture *tex = SDL_CreateTextureFromSurface(ren, sur);
	SDL_FreeSurface(sur);
	return tex;
}

static void putPixel(SDL_Surface *surface, int x, int y, Uint32 color)
{
	if (x < 0 || x >= surface->w || y < 0 || y >= surface->h)
		return;

	Uint32 *pixels = (Uint32 *) surface->pixels;
	pixels[(y * surface->w) + x] = color;
}

static void drawLine(SDL_Surface *surface, SDL_Point p0, SDL_Point p1,
		     Uint32 color)
{
	int x0 = p0.x;
	int y0 = p0.y;
	int x1 = p1.x;
	int y1 = p1.y;

	int dx = abs(x1 - x0);
	int sx = x0 < x1 ? 1 : -1;
	int dy = -abs(y1 - y0);
	int sy = y0 < y1 ? 1 : -1;
	int err = dx + dy;
	int e2;

	while (1) {
		putPixel(surface, x0, y0, color);

		if (x0 == x1 && y0 == y1)
			break;

		e2 = 2 * err;
		if (e2 >= dy) {
			err += dy;
			x0 += sx;
		}
		if (e2 <= dx) {
			err += dx;
			y0 += sy;
		}
	}
}

static SDL_Surface *getCompassSurface(SDL_Rect db, TTF_Font *font, double angle)
{
	int radius = (db.h / 2) - 10;
	SDL_Surface *dataSur =
	    SDL_CreateRGBSurfaceWithFormat(0, db.w, db.h, 32, pixfmt);

	SDL_FillRect(dataSur, NULL, SDL_MapRGB(dataSur->format, 32, 32, 32));

	Uint32 white = SDL_MapRGB(dataSur->format, 255, 255, 255);

	int centreX = db.w / 2;
	int centreY = db.h / 2;

	const int32_t diameter = (radius * 2);

	int32_t x = (radius - 1);
	int32_t y = 0;
	int32_t tx = 1;
	int32_t ty = 1;
	int32_t error = (tx - diameter);

	while (x >= y) {
		putPixel(dataSur, centreX + x, centreY - y, white);
		putPixel(dataSur, centreX + x, centreY + y, white);
		putPixel(dataSur, centreX - x, centreY - y, white);
		putPixel(dataSur, centreX - x, centreY + y, white);
		putPixel(dataSur, centreX + y, centreY - x, white);
		putPixel(dataSur, centreX + y, centreY + x, white);
		putPixel(dataSur, centreX - y, centreY - x, white);
		putPixel(dataSur, centreX - y, centreY + x, white);

		if (error <= 0) {
			++y;
			error += ty;
			ty += 2;
		}

		if (error > 0) {
			--x;
			tx += 2;
			error += (tx - diameter);
		}
	}
	char s[256];
	sprintf(s, "Angle: %0.3f", angle);
	SDL_Surface *nameSurf =
	    (font ? TTF_RenderUTF8_Blended_Wrapped(font, s, Yellow,
						   nameWrapWidth) : NULL);

	SDL_Point center = { centreX, centreY };
	SDL_Point b1 = {
		(int)(20 * cos((M_PI / 180) * (angle + 90)) + center.x),
		(int)(-20 * sin((M_PI / 180) * (angle + 90)) + center.y)
	};
	SDL_Point b2 = {
		(int)(20 * cos((M_PI / 180) * (angle - 90)) + center.x),
		(int)(-20 * sin((M_PI / 180) * (angle - 90)) + center.y)
	};
	SDL_Point p1 = {
		(int)(0.95 * radius * cos((M_PI / 180) * angle) + center.x),
		(int)(-0.95 * radius * sin((M_PI / 180) * angle) + center.y)
	};

	Uint32 red_color = SDL_MapRGB(dataSur->format, Red.r, Red.g, Red.b);
	drawLine(dataSur, b1, b2, red_color);
	for (int i = 0; i < 8; i++) {
		SDL_Point a1 =
		    { (int)((20 - i) * cos((M_PI / 180) * (angle + 90)) +
			    center.x),
			(int)(-(20 - i) * sin((M_PI / 180) * (angle + 90)) +
			      center.y)
		}, a2 =
		    { (int)((20 - i) * cos((M_PI / 180) * (angle - 90)) +
			    center.x),
			(int)(-(20 - i) * sin((M_PI / 180) * (angle - 90)) +
			      center.y)
		};
		drawLine(dataSur, a1, p1, red_color);
		drawLine(dataSur, a2, p1, red_color);
	}
	if (nameSurf) {
		SDL_Rect nameDst =
		    { center.x - nameSurf->w / 2, center.y + 50, nameSurf->w,
			nameSurf->h
		};
		SDL_BlitSurface(nameSurf, NULL, dataSur, &nameDst);
	}

	if (nameSurf)
		SDL_FreeSurface(nameSurf);

	return dataSur;
}

double s1 = 0, s2 = 0, s3 = 0;

static SDL_Surface *getAccelSurface(SDL_Rect db, TTF_Font *font)
{
	SDL_Surface *dataSur =
	    SDL_CreateRGBSurfaceWithFormat(0, db.w, db.h, 32, pixfmt);
	SDL_FillRect(dataSur, NULL, SDL_MapRGB(dataSur->format, 32, 32, 32));

	int centreX = db.w / 2;
	int centreY = db.h / 2;

	char s[256], d[256];
	pthread_mutex_lock(&accelMutex);

	double ax = accel[0] - s1;
	double ay = accel[1] - s2;
	double az = accel[2] - s3;
	double r = sqrt(ax * ax + ay * ay + az * az);
	pthread_mutex_lock(&zerodMutex);
	if (zerod) {
		s1 = ax;
		s2 = ay;
		s3 = az;
		zerod = 0;
	}
	pthread_mutex_unlock(&zerodMutex);

	double theta = (r == 0) ? 0 : acos(az / r) * 180.0 / M_PI;
	double phi = atan2(ay, ax) * 180.0 / M_PI;

	sprintf(s, "Accel: X:%0.2f Y:%0.2f Z:%0.2f", ax, ay, az);
	sprintf(d, "AZI: %0.2f°, ZEN: %0.2f°", phi, theta);

	pthread_mutex_unlock(&accelMutex);

	SDL_Surface *nameSurf =
	    (font ? TTF_RenderUTF8_Blended(font, s, Yellow) : NULL);
	SDL_Surface *aziSurf =
	    (font ? TTF_RenderUTF8_Blended_Wrapped(font, d, Yellow, 300) :
	     NULL);

	SDL_Rect nameDst = { (centreX - nameSurf->w / 2), 10,
		nameSurf->w, nameSurf->h
	};
	SDL_Rect aziDst = { nameDst.x, nameDst.y + nameDst.h + 5,
		aziSurf->w, aziSurf->h
	};

	if (nameSurf && aziSurf) {
		SDL_BlitSurface(nameSurf, NULL, dataSur, &nameDst);
		SDL_BlitSurface(aziSurf, NULL, dataSur, &aziDst);
	}
	SDL_Point center = { centreX, (db.h + aziDst.y + aziDst.h) / 2 };

	int lineLen = 50;	// fixed radius length for display
	SDL_Point a1 = { center.x - 20, center.y };
	SDL_Point a2 = { center.x + 20, center.y };
	SDL_Point a4 = { center.x - 20, center.y - 20 };
	SDL_Point a3 = { center.x + 20, center.y - 20 };
	SDL_Point p1 = {
		(int)(center.x + (r > 0 ? (ax / r) * lineLen : 0)),
		(int)(center.y - (r > 0 ? (ay / r) * lineLen : 0) -
		      (r > 0 ? (az / r) * 0.5 * lineLen : 0))
	};

	Uint32 red_color = SDL_MapRGB(dataSur->format, Red.r, Red.g, Red.b);
	drawLine(dataSur, a1, a2, red_color);
	drawLine(dataSur, a2, a3, red_color);
	drawLine(dataSur, a3, a4, red_color);
	drawLine(dataSur, a4, a1, red_color);
	drawLine(dataSur, a1, p1, red_color);
	drawLine(dataSur, a2, p1, red_color);
	drawLine(dataSur, a3, p1, red_color);
	drawLine(dataSur, a4, p1, red_color);

	if (nameSurf)
		SDL_FreeSurface(nameSurf);
	if (aziSurf)
		SDL_FreeSurface(aziSurf);

	return dataSur;
}


